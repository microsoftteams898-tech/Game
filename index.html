<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Jet: Boss Rush Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Rajdhani:wght@500;700&display=swap');

        :root {
            --neon-blue: #00f3ff;
            --neon-pink: #ff0055;
            --neon-gold: #ffd700;
            --neon-purple: #bf00ff;
        }

        body, html {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            background: #05000a;
            overflow: hidden;
            font-family: 'Rajdhani', sans-serif;
            color: #fff;
            user-select: none;
            touch-action: none;
        }

        #game-container {
            position: relative; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
        }

        canvas { display: block; }

        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }

        /* HUD */
        #hud {
            justify-content: space-between; align-items: flex-start;
            padding: 20px; width: 100%; height: auto; position: absolute; top: 0; z-index: 10;
        }

        .hud-panel {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255,255,255,0.2);
            padding: 10px 20px; border-radius: 4px;
            backdrop-filter: blur(4px);
            border-bottom: 3px solid var(--neon-blue);
        }

        .stat-label { font-size: 0.8rem; color: #aaa; text-transform: uppercase; letter-spacing: 2px; }
        .stat-value { font-family: 'Black Ops One', cursive; font-size: 2rem; color: #fff; line-height: 1; text-shadow: 0 0 10px var(--neon-blue); }

        #health-bar {
            width: 250px; height: 10px; background: #333; margin-top: 5px; border-radius: 2px; overflow: hidden;
        }
        #health-fill { width: 100%; height: 100%; background: var(--neon-pink); box-shadow: 0 0 10px var(--neon-pink); transition: width 0.1s; }

        /* BOSS HEALTH BAR (Extra) */
        #boss-hud {
            position: absolute; top: 70px; left: 50%; transform: translateX(-50%);
            width: 60%; height: 20px; background: rgba(0,0,0,0.8);
            border: 2px solid var(--neon-gold); border-radius: 10px;
            display: none; z-index: 12;
        }
        #boss-hud.active { display: block; }
        #boss-hp-fill { width: 100%; height: 100%; background: var(--neon-gold); transition: width 0.2s; border-radius: 8px;}
        #boss-name { position: absolute; top: -25px; width: 100%; text-align: center; color: var(--neon-gold); font-weight: bold; font-family: 'Black Ops One'; letter-spacing: 2px; text-shadow: 0 0 10px var(--neon-gold); }

        /* UPGRADE BARS */
        #upgrade-container {
            position: absolute; bottom: 20px; left: 20px;
            display: flex; flex-direction: column; gap: 10px; align-items: flex-start;
            width: 200px;
        }
        .timer-box {
            display: flex; align-items: center; gap: 10px;
            width: 100%; opacity: 0; transition: opacity 0.3s;
        }
        .timer-box.active { opacity: 1; }
        .timer-icon {
            width: 40px; height: 40px; border: 2px solid; border-radius: 8px;
            display: flex; justify-content: center; align-items: center;
            font-weight: bold; font-size: 1.2rem; font-family: 'Black Ops One';
            background: rgba(0,0,0,0.5); flex-shrink: 0;
        }
        .timer-bar-bg { flex-grow: 1; height: 8px; background: rgba(255,255,255,0.2); border-radius: 4px; overflow: hidden; }
        .timer-bar-fill { height: 100%; width: 0%; transition: width 0.1s linear; }

        /* ANNOUNCER */
        #announcement {
            position: absolute; top: 25%; left: 50%; transform: translateX(-50%);
            text-align: center; z-index: 15; opacity: 0; transition: 0.2s;
            text-shadow: 0 0 20px currentColor; pointer-events: none;
        }
        #announcement.active { opacity: 1; transform: translateX(-50%) scale(1.2); }
        #announcement h1 { font-family: 'Black Ops One'; font-size: 5rem; margin: 0; color: #fff; }
        #announcement p { font-size: 2rem; color: var(--neon-pink); margin-top: 5px; font-weight: bold; }

        /* SCREENS */
        #start-screen, #game-over-screen {
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid var(--neon-blue);
            padding: 40px; text-align: center; pointer-events: auto; z-index: 20;
            box-shadow: 0 0 100px rgba(0, 243, 255, 0.2);
            max-width: 500px;
        }

        h1.main-title {
            font-family: 'Black Ops One'; font-size: 3.5rem;
            color: var(--neon-blue); text-shadow: 0 0 20px var(--neon-blue);
            margin-bottom: 10px;
        }

        .btn {
            background: var(--neon-blue); color: #000; border: none;
            font-family: 'Black Ops One'; font-size: 1.5rem; padding: 15px 40px;
            cursor: pointer; margin-top: 20px; text-transform: uppercase;
            transition: 0.2s; clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
        }
        .btn:hover { background: #fff; transform: scale(1.05); box-shadow: 0 0 30px #fff; }
        .hidden { opacity: 0; pointer-events: none; }
    </style>
</head>
<body>

    <main id="game-container">
        <canvas id="gameCanvas"></canvas>

        <!-- ANNOUNCER -->
        <div id="announcement">
            <h1 id="ann-title">WAVE 1</h1>
            <p id="ann-sub">BEREIT</p>
        </div>

        <!-- HUD -->
        <div id="hud" class="ui-layer hidden">
            <div class="hud-panel">
                <div class="stat-label">WAVE</div>
                <div class="stat-value" id="wave-display">1</div>
            </div>
            
            <!-- BOSS HUD -->
            <div id="boss-hud">
                <div id="boss-name">DESTROYER</div>
                <div id="boss-hp-fill"></div>
            </div>

            <div class="hud-panel" style="text-align: center; border-bottom-color: var(--neon-pink);">
                <div class="stat-label">SCORE</div>
                <div class="stat-value" id="score-display">0</div>
            </div>

            <div class="hud-panel" style="text-align: right; border-bottom-color: #00ff00;">
                <div class="stat-label">HULL</div>
                <div id="health-bar"><div id="health-fill"></div></div>
            </div>
        </div>

        <!-- TIMER UI -->
        <div id="upgrade-container" class="ui-layer hidden" style="pointer-events: none;">
            <div class="timer-box" id="timer-multi">
                <div class="timer-icon" style="border-color: gold; color: gold;">M</div>
                <div class="timer-bar-bg"><div class="timer-bar-fill" id="bar-multi" style="background: gold;"></div></div>
            </div>
            <div class="timer-box" id="timer-rapid">
                <div class="timer-icon" style="border-color: var(--neon-blue); color: var(--neon-blue);">⚡</div>
                <div class="timer-bar-bg"><div class="timer-bar-fill" id="bar-rapid" style="background: var(--neon-blue);"></div></div>
            </div>
        </div>

        <!-- START SCREEN -->
        <div id="start-screen" class="ui-layer">
            <h1 class="main-title">BOSS RUSH</h1>
            <p style="color: #ddd; margin-bottom: 30px;">
                Jede Welle hat einen Boss.<br>
                4 Verschiedene Gegner Typen.<br>
                Steuerung repariert & Unendlich.
            </p>
            <button class="btn" id="start-btn">START</button>
        </div>

        <!-- GAME OVER -->
        <div id="game-over-screen" class="ui-layer hidden">
            <h1 style="color: var(--neon-pink); font-size: 3rem;">MISSION FAILED</h1>
            <p>Welle: <span id="final-wave" style="color:#fff">1</span></p>
            <p>Score: <span id="final-score" style="color:var(--neon-blue)">0</span></p>
            <button class="btn" id="restart-btn">NOCHMAL</button>
        </div>
    </main>

    <script>
        /* --- AUDIO SYSTEM --- */
        const AudioSys = {
            ctx: null,
            init: function() { window.AudioContext = window.AudioContext || window.webkitAudioContext; this.ctx = new AudioContext(); },
            playTone: function(freq, type, decay, vol) {
                if(!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + decay);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + decay);
            },
            shoot: () => AudioSys.playTone(600, 'square', 0.05, 0.05),
            explosion: () => AudioSys.playTone(80, 'sawtooth', 0.3, 0.15),
            powerup: () => AudioSys.playTone(1200, 'sine', 0.3, 0.1),
            hit: () => AudioSys.playTone(200, 'triangle', 0.1, 0.1),
            powerdown: () => AudioSys.playTone(200, 'sawtooth', 0.5, 0.1),
            boss: () => AudioSys.playTone(50, 'sawtooth', 1.0, 0.3)
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); 
        const ui = {
            hud: document.getElementById('hud'),
            bossHud: document.getElementById('boss-hud'),
            bossHp: document.getElementById('boss-hp-fill'),
            bossName: document.getElementById('boss-name'),
            upg: document.getElementById('upgrade-container'),
            start: document.getElementById('start-screen'),
            over: document.getElementById('game-over-screen'),
            ann: document.getElementById('announcement'),
            wave: document.getElementById('wave-display'),
            score: document.getElementById('score-display'),
            hpFill: document.getElementById('health-fill'),
            fw: document.getElementById('final-wave'),
            fs: document.getElementById('final-score'),
            annTitle: document.getElementById('ann-title'),
            annSub: document.getElementById('ann-sub'),
            timerMulti: document.getElementById('timer-multi'),
            timerRapid: document.getElementById('timer-rapid'),
            barMulti: document.getElementById('bar-multi'),
            barRapid: document.getElementById('bar-rapid')
        };

        let width, height;
        let gameRunning = false;
        let frames = 0;
        let score = 0;
        let shake = 0;

        // Wave Logic
        let wave = 1;
        let waveState = 'PREP'; 
        let enemiesToSpawn = 0;
        let enemiesSpawned = 0;
        let waveTimer = 0;
        let bossActive = false;
        let bossMaxHp = 0;

        // Entities
        let player;
        let bullets = [];
        let enemies = [];
        let particles = [];
        let powerups = [];
        let stars = [];
        let floatingTexts = [];

        // Upgrade Constants
        const UPGRADE_DURATION = 600;

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            initStars();
        }
        window.addEventListener('resize', resize);

        /* --- CLASSES --- */

        class Player {
            constructor() {
                this.x = width/2; this.y = height - 100;
                this.tx = this.x; this.ty = this.y;
                this.hp = 100; this.maxHp = 100;
                this.bulletCount = 1; 
                this.spread = 0;      
                this.fireRate = 12;   
                this.bulletSpeed = 20; // Etwas schneller für mehr Präzision
                this.multiTimer = 0;
                this.rapidTimer = 0;
                this.color = '#00f3ff';
                this.invulnerable = 0;
                this.r = 15; // Radius für Kollision
            }
            update() {
                // Präzisere Steuerung (Lerp 0.2 statt 0.15)
                this.x += (this.tx - this.x) * 0.2;
                this.y += (this.ty - this.y) * 0.2;
                
                if(this.x < this.r) this.x = this.r;
                if(this.x > width-this.r) this.x = width-this.r;
                if(this.y < this.r) this.y = this.r;
                if(this.y > height-this.r) this.y = height-this.r;

                if(this.invulnerable > 0) this.invulnerable--;

                if(this.multiTimer > 0) {
                    this.multiTimer--;
                    if(this.multiTimer <= 0) {
                        this.bulletCount = 1;
                        this.spread = 0;
                        AudioSys.powerdown();
                        showFloatingText("MULTI ENDE", this.x, this.y-40, "#aaa");
                    }
                }
                if(this.rapidTimer > 0) {
                    this.rapidTimer--;
                    if(this.rapidTimer <= 0) {
                        this.fireRate = 12;
                        AudioSys.powerdown();
                        showFloatingText("RAPID ENDE", this.x, this.y-40, "#aaa");
                    }
                }
            }
            draw() {
                if(this.invulnerable > 0 && Math.floor(frames/4)%2 === 0) return;
                ctx.save();
                ctx.translate(this.x, this.y);
                const tilt = (this.tx - this.x) * 0.05;
                ctx.rotate(tilt * Math.PI/180);

                ctx.fillStyle = '#000';
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;
                
                ctx.beginPath();
                ctx.moveTo(0, -35); ctx.lineTo(12, 0); ctx.lineTo(30, 15);
                ctx.lineTo(12, 30); ctx.lineTo(0, 25);
                ctx.lineTo(-12, 30); ctx.lineTo(-30, 15);
                ctx.lineTo(-12, 0);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.shadowBlur = 15; ctx.shadowColor = '#fff';
                ctx.beginPath(); ctx.ellipse(0, -10, 4, 8, 0, 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur = 0;

                ctx.fillStyle = `rgba(0, 243, 255, ${0.5 + Math.random()*0.5})`;
                ctx.shadowBlur = 10; ctx.shadowColor = '#00f3ff';
                ctx.beginPath(); 
                ctx.moveTo(-12, 30); ctx.lineTo(-6, 45+rnd(15)); ctx.lineTo(0, 30); 
                ctx.lineTo(6, 45+rnd(15)); ctx.lineTo(12, 30); 
                ctx.fill();

                ctx.restore();
            }
            shoot() {
                AudioSys.shoot();
                const count = this.bulletCount;
                const angleStep = this.spread / (count - 1 || 1);
                let startAngle = -this.spread / 2;
                
                for(let i=0; i<count; i++) {
                    let angle = count === 1 ? 0 : startAngle + (i * angleStep);
                    bullets.push(new Bullet(this.x, this.y-30, angle));
                }
            }
            takeDamage(dmg) {
                if(this.invulnerable > 0) return;
                this.hp -= dmg;
                shake = 20;
                updateHealthUI();
                spawnParticles(this.x, this.y, this.color, 20);
                // Hit Sound
                AudioSys.hit();
                
                // Rot Blink Effekt auf dem HUD
                ui.hud.style.borderColor = 'red';
                setTimeout(() => ui.hud.style.borderColor = 'rgba(255,255,255,0.2)', 200);

                if(this.hp <= 0) endGame();
            }
            heal(amt) {
                this.hp = Math.min(this.maxHp, this.hp + amt);
                updateHealthUI();
                showFloatingText("HEAL", this.x, this.y-40, "#00ff00");
            }
            activateMulti() {
                this.multiTimer = UPGRADE_DURATION;
                this.bulletCount = 5; 
                this.spread = 0.6;   
                showFloatingText("MEGA SHOT!", this.x, this.y-50, "gold");
            }
            activateRapid() {
                this.rapidTimer = UPGRADE_DURATION;
                this.fireRate = 3;   
                showFloatingText("RAPID FIRE!", this.x, this.y-50, "cyan");
            }
        }

        class Bullet {
            constructor(x, y, angleOffset) {
                this.x = x; this.y = y;
                this.vx = Math.sin(angleOffset) * player.bulletSpeed;
                this.vy = -Math.cos(angleOffset) * player.bulletSpeed;
                this.active = true;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                if(this.y < -50 || this.x < -50 || this.x > width+50) this.active = false;
            }
            draw() {
                ctx.fillStyle = '#ccff00';
                ctx.shadowBlur = 10; ctx.shadowColor = '#ccff00';
                ctx.fillRect(this.x - 6, this.y - 12, 12, 24);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(this.x - 2, this.y - 8, 4, 16);
                ctx.shadowBlur = 0;
            }
        }

        // --- GEGNER TYPEN ---
        class Enemy {
            constructor(waveLvl, type = 'NORMAL') {
                this.type = type;
                this.active = true;
                this.y = -40;

                if (this.type === 'BOSS') {
                    // BOSS SETUP
                    this.r = 60;
                    bossMaxHp = 50 + (waveLvl * 20);
                    this.hp = bossMaxHp;
                    this.maxHp = bossMaxHp;
                    this.speed = 0.5 + (waveLvl * 0.05); // Sehr langsam
                    this.color = '#ffd700'; // Gold
                    this.score = 5000;
                    this.x = width/2;
                    this.vx = rnd(-1, 1);
                    this.angle = 0;
                    this.name = "DESTROYER";
                    
                    // Boss Rotation (alle 3 Wellen anderer Style)
                    const bossStyle = waveLvl % 3;
                    if(bossStyle === 1) { this.color = '#bf00ff'; this.name = "OVERLORD"; } // Lila
                    if(bossStyle === 2) { this.color = '#ff0000'; this.name = "DOOMBRINGER"; } // Rot

                } else {
                    // MINIONS SETUP
                    // Zufälliger Typ basierend auf Welle
                    const rand = Math.random();
                    if (waveLvl > 3 && rand < 0.2) this.type = 'CHASER';
                    else if (waveLvl > 2 && rand < 0.5) this.type = 'TANK';
                    else if (rand < 0.7) this.type = 'SPRINTER';
                    else this.type = 'NORMAL';

                    this.x = rnd(20, width-20);

                    switch(this.type) {
                        case 'TANK':
                            this.r = 40;
                            this.hp = 5 + Math.floor(waveLvl * 1.5);
                            this.speed = 1.0 + (waveLvl * 0.05);
                            this.color = '#bf00ff'; // Lila
                            this.score = 300;
                            this.vx = rnd(-0.5, 0.5);
                            break;
                        case 'SPRINTER':
                            this.r = 15;
                            this.hp = 1;
                            this.speed = 4.0 + (waveLvl * 0.2); // Schnell
                            this.color = '#ffff00'; // Gelb
                            this.score = 150;
                            this.vx = rnd(-2, 2);
                            break;
                        case 'CHASER':
                            this.r = 25;
                            this.hp = 2 + Math.floor(waveLvl * 0.5);
                            this.speed = 2.0 + (waveLvl * 0.1);
                            this.color = '#ff0055'; // Rot
                            this.score = 200;
                            this.vx = 0; // Wird dynamisch gesetzt
                            break;
                        default: // NORMAL
                            this.r = 20;
                            this.hp = 1 + Math.floor(waveLvl * 0.5);
                            this.speed = 1.5 + (waveLvl * 0.1);
                            this.color = '#00f3ff'; // Blau
                            this.score = 100;
                            this.vx = rnd(-0.5, 0.5);
                            break;
                    }
                    this.angle = 0;
                }
            }
            update() {
                this.y += this.speed;

                if (this.type === 'CHASER') {
                    // Verfolgt Spieler X
                    if (this.x < player.x) this.x += 1;
                    else if (this.x > player.x) this.x -= 1;
                } else {
                    this.x += this.vx;
                }

                this.angle += 0.05;

                if(this.x < this.r || this.x > width-this.r) this.vx *= -1;
                if(this.y > height+100) this.active = false;
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.strokeStyle = this.color;
                ctx.lineWidth = (this.type === 'BOSS') ? 6 : 3;
                ctx.shadowBlur = 15; ctx.shadowColor = this.color;

                ctx.beginPath();
                if (this.type === 'BOSS') {
                    // Komplexes Boss Design
                    for(let i=0; i<6; i++) {
                        const rad = (i%2===0) ? this.r : this.r/1.5;
                        ctx.lineTo(rad*Math.cos(i*Math.PI/3), rad*Math.sin(i*Math.PI/3));
                    }
                } else if (this.type === 'TANK') {
                    // Quadrat
                    ctx.rect(-this.r/2, -this.r/2, this.r, this.r);
                } else if (this.type === 'SPRINTER') {
                    // Dreieck (Spitze nach unten)
                    ctx.moveTo(0, this.r); ctx.lineTo(this.r, -this.r); ctx.lineTo(-this.r, -this.r);
                } else if (this.type === 'CHASER') {
                    // Pfeil (Spitze zu Spieler) - Zeigt aber nur Rotation
                    ctx.moveTo(0, this.r); ctx.lineTo(this.r, 0); ctx.lineTo(0, -this.r); ctx.lineTo(-this.r, 0);
                } else {
                    // Kreis
                    ctx.arc(0, 0, this.r, 0, Math.PI*2);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // HP Balken für Tanks und Bosse
                if((this.type === 'TANK' || this.type === 'BOSS') && this.hp < this.maxHp) {
                    ctx.rotate(-this.angle); // Balken nicht drehen
                    ctx.fillStyle = 'red';
                    ctx.fillRect(-20, -this.r - 10, 40, 5);
                    ctx.fillStyle = '#0f0';
                    const pct = Math.max(0, (this.hp / this.maxHp) * 40);
                    ctx.fillRect(-20, -this.r - 10, pct, 5);
                }

                ctx.restore();
            }
        }

        class PowerUp {
            constructor() {
                this.x = rnd(30, width-30); this.y = -30;
                this.r = 20; this.vy = 2;
                this.active = true;
                
                const rand = Math.random();
                if(rand < 0.1) { this.type = 'NUKE'; this.color = '#ff0000'; this.symbol = '☢️'; }
                else if(rand < 0.45) { this.type = 'MULTI'; this.color = '#ffd700'; this.symbol = 'M'; } 
                else if(rand < 0.75) { this.type = 'RAPID'; this.color = '#00f3ff'; this.symbol = '⚡'; } 
                else { this.type = 'HEAL'; this.color = '#00ff00'; this.symbol = '+'; }
            }
            update() {
                this.y += this.vy;
                if(this.y > height+50) this.active = false;
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 20; ctx.shadowColor = this.color;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#000';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(this.symbol, this.x, this.y);
            }
        }

        class Particle {
            constructor(x, y, color, speedScale=1) {
                this.x = x; this.y = y; this.color = color;
                const a = rnd(0, Math.PI*2);
                const s = rnd(1, 6) * speedScale;
                this.vx = Math.cos(a) * s;
                this.vy = Math.sin(a) * s;
                this.life = 1; this.decay = rnd(0.02, 0.05);
                this.active = true;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                this.vx *= 0.94; this.vy *= 0.94;
                this.life -= this.decay;
                if(this.life <= 0) this.active = false;
            }
            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x-2, this.y-2, 4, 4);
                ctx.globalAlpha = 1;
            }
        }

        class FloatingText {
            constructor(text, x, y, color) {
                this.text = text; this.x = x; this.y = y; this.color = color;
                this.life = 1; this.vy = -2;
                this.active = true;
            }
            update() {
                this.y += this.vy;
                this.life -= 0.02;
                if(this.life <= 0) this.active = false;
            }
            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.font = 'bold 24px Black Ops One';
                ctx.fillText(this.text, this.x, this.y);
                ctx.globalAlpha = 1;
            }
        }

        /* --- SYSTEM --- */

        function rnd(min, max) { return Math.random() * (max-min) + min; }

        function initStars() {
            stars = [];
            for(let i=0; i<100; i++) {
                stars.push({
                    x: Math.random()*width, y: Math.random()*height,
                    z: Math.random()*3+0.5,
                    color: Math.random() > 0.9 ? '#ff0055' : (Math.random() > 0.8 ? '#00f3ff' : '#ffffff')
                });
            }
        }

        function spawnParticles(x, y, color, count=10) {
            if(particles.length > 300) particles.shift(); 
            for(let i=0; i<count; i++) particles.push(new Particle(x, y, color));
        }

        function showFloatingText(text, x, y, color='#fff') {
            if(floatingTexts.length > 50) floatingTexts.shift();
            floatingTexts.push(new FloatingText(text, x, y, color));
        }

        function updateUpgradeUI() {
            if(player.multiTimer > 0) {
                ui.timerMulti.classList.add('active');
                const pct = (player.multiTimer / UPGRADE_DURATION) * 100;
                ui.barMulti.style.width = pct + '%';
            } else {
                ui.timerMulti.classList.remove('active');
            }

            if(player.rapidTimer > 0) {
                ui.timerRapid.classList.add('active');
                const pct = (player.rapidTimer / UPGRADE_DURATION) * 100;
                ui.barRapid.style.width = pct + '%';
            } else {
                ui.timerRapid.classList.remove('active');
            }
        }

        function updateHealthUI() {
            const pct = Math.max(0, (player.hp / player.maxHp) * 100);
            ui.hpFill.style.width = `${pct}%`;
            if(pct < 30) ui.hpFill.style.background = '#ff0000';
            else ui.hpFill.style.background = '#ff0055';
        }

        function updateBossUI() {
            const boss = enemies.find(e => e.type === 'BOSS');
            if(boss && boss.active) {
                ui.bossHud.classList.add('active');
                ui.bossName.innerText = boss.name;
                const pct = Math.max(0, (boss.hp / boss.maxHp) * 100);
                ui.bossHp.style.width = `${pct}%`;
            } else {
                ui.bossHud.classList.remove('active');
            }
        }

        function nukeScreen() {
            AudioSys.explosion();
            shake = 30;
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.fillRect(0,0,width,height);
            
            enemies.forEach(e => {
                if(e.active) {
                    spawnParticles(e.x, e.y, e.color, 10); 
                    score += e.score;
                    e.active = false;
                }
            });
            enemies = enemies.filter(e => e.active);
            ui.score.innerText = score;
            ui.bossHud.classList.remove('active');
        }

        function announce(title, sub) {
            ui.annTitle.innerText = title;
            ui.annSub.innerText = sub;
            ui.ann.classList.add('active');
            setTimeout(() => ui.ann.classList.remove('active'), 1500);
        }

        /* --- LOOP --- */

        function init() {
            player = new Player();
            bullets = []; enemies = []; particles = []; powerups = []; floatingTexts = [];
            score = 0; wave = 1; frames = 0;
            waveState = 'PREP'; waveTimer = 120;
            shake = 0; bossActive = false;
            
            ui.hud.classList.remove('hidden');
            ui.upg.classList.remove('hidden'); 
            ui.start.classList.add('hidden');
            ui.over.classList.add('hidden');
            ui.bossHud.classList.remove('active');
            ui.wave.innerText = '1';
            ui.score.innerText = '0';
            updateHealthUI();
            announce("SYSTEM ONLINE", "WAVE 1 START");
        }

        function manageWaves() {
            if(waveState === 'PREP') {
                if(waveTimer <= 0) {
                    waveState = 'FIGHT';
                    announce(`WAVE ${wave}`, "ANGRIFF!");
                    enemiesToSpawn = 5 + (wave * 2); // Anzahl Gegner
                    bossActive = false;
                } else {
                    waveTimer--;
                }
            } else if (waveState === 'FIGHT') {
                
                // 1. Spawn Minions
                if (!bossActive && enemiesSpawned < enemiesToSpawn) {
                    const spawnRate = Math.max(30, 80 - (wave * 2)); 
                    if(frames % spawnRate === 0) {
                        enemies.push(new Enemy(wave, 'NORMAL')); // Zufälliger Typ im Konstruktor
                        enemiesSpawned++;
                    }
                }

                // 2. Spawn BOSS am Ende der Welle
                if (!bossActive && enemiesSpawned >= enemiesToSpawn && enemies.length === 0) {
                    bossActive = true;
                    AudioSys.boss();
                    announce("WARNUNG", "BOSS ERSCHIENEN!");
                    enemies.push(new Enemy(wave, 'BOSS'));
                }

                // 3. Check Wave End (Boss tot?)
                const boss = enemies.find(e => e.type === 'BOSS');
                if (bossActive && (!boss || !boss.active)) {
                    wave++;
                    waveState = 'PREP';
                    waveTimer = 180; 
                    bossActive = false;
                    ui.wave.innerText = wave;
                    player.heal(50); // Viel Heilung nach Boss
                    announce(`WAVE ${wave}`, "GEWONNEN");
                    enemiesSpawned = 0;
                    enemiesToSpawn = 0;
                }
            }
        }

        function loop() {
            if(!gameRunning) return;
            requestAnimationFrame(loop);
            frames++;

            updateUpgradeUI();
            updateBossUI();

            ctx.save();
            if(shake > 0) {
                ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);
                shake *= 0.9; if(shake<0.5) shake=0;
            }

            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, '#020005'); 
            gradient.addColorStop(1, '#000000');
            ctx.fillStyle = gradient;
            ctx.fillRect(0,0,width,height);

            ctx.globalCompositeOperation = 'lighter';

            stars.forEach(s => {
                s.y += s.z; if(s.y>height) {s.y=0; s.x=rnd(0,width);}
                ctx.fillStyle = s.color; ctx.globalAlpha = s.z/3;
                ctx.fillRect(s.x, s.y, s.z, s.z);
            });
            ctx.globalAlpha = 1;

            manageWaves();

            player.update();
            player.draw();
            
            if(frames % player.fireRate === 0 && waveState === 'FIGHT') player.shoot();

            // Updates
            
            for(let i = bullets.length - 1; i >= 0; i--) {
                let b = bullets[i];
                b.update();
                b.draw();
                if(!b.active) bullets.splice(i, 1);
            }

            for(let i = enemies.length - 1; i >= 0; i--) {
                let e = enemies[i];
                e.update();
                e.draw();

                // Collision Player
                const dist = Math.hypot(player.x - e.x, player.y - e.y);
                // Hitbox etwas vergrößert für Fairness (Player 15 + Enemy Radius + 5 Puffer)
                if(dist < player.r + e.r + 5) {
                    player.takeDamage(15);
                    spawnParticles(e.x, e.y, e.color, 15);
                    if(e.type !== 'BOSS') e.active = false; // Minions sterben bei Aufprall
                }

                for(let j = bullets.length - 1; j >= 0; j--) {
                    let b = bullets[j];
                    const bDist = Math.hypot(b.x - e.x, b.y - e.y);
                    // Bullet Hitbox
                    if(bDist < e.r + 10) { 
                        b.active = false;
                        spawnParticles(b.x, b.y, '#fff', 3); 
                        e.hp--;
                        if(e.hp <= 0) {
                            AudioSys.explosion();
                            spawnParticles(e.x, e.y, e.color, (e.type==='BOSS'?50:15));
                            score += e.score;
                            showFloatingText("+"+e.score, e.x, e.y);
                            
                            // Drops nur bei Minions (Boss heilt dich stattdessen durch Welle Ende)
                            if(e.type !== 'BOSS' && Math.random() < 0.40) powerups.push(new PowerUp());
                            e.active = false;
                        }
                        break;
                    }
                }
                if(!e.active) enemies.splice(i, 1);
            }

            for(let i = powerups.length - 1; i >= 0; i--) {
                let p = powerups[i];
                p.update();
                p.draw();
                const dist = Math.hypot(player.x - p.x, player.y - p.y);
                if(dist < p.r + 25) {
                    AudioSys.powerup();
                    if(p.type === 'NUKE') { nukeScreen(); showFloatingText("NUKE!", width/2, height/2, "red"); }
                    if(p.type === 'MULTI') { player.activateMulti(); }
                    if(p.type === 'RAPID') { player.activateRapid(); }
                    if(p.type === 'HEAL') { player.heal(40); }
                    p.active = false;
                }
                if(!p.active) powerups.splice(i, 1);
            }

            for(let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.update();
                p.draw();
                if(!p.active) particles.splice(i, 1);
            }

            for(let i = floatingTexts.length - 1; i >= 0; i--) {
                let t = floatingTexts[i];
                t.update();
                t.draw();
                if(!t.active) floatingTexts.splice(i, 1);
            }

            ctx.globalCompositeOperation = 'source-over';
            ctx.restore();
        }

        function endGame() {
            gameRunning = false;
            ui.fw.innerText = wave;
            ui.fs.innerText = score;
            ui.hud.classList.add('hidden');
            ui.upg.classList.add('hidden');
            ui.bossHud.classList.add('hidden');
            ui.over.classList.remove('hidden');
        }

        /* --- INPUT --- */
        function start() { AudioSys.init(); init(); gameRunning=true; loop(); }
        
        window.addEventListener('mousemove', e => { if(gameRunning) { player.tx = e.clientX; player.ty = e.clientY; } });
        window.addEventListener('touchmove', e => { 
            if(gameRunning) { e.preventDefault(); player.tx = e.touches[0].clientX; player.ty = e.touches[0].clientX; } // Typo fix in touch logic
        }, {passive:false});

        document.getElementById('start-btn').onclick = start;
        document.getElementById('restart-btn').onclick = start;

        resize();
        initStars();

    </script>
</body>
</html>
